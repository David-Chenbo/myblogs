### 1、正则表达式的概念

正则表达式：regular expression，也叫regex、RE，是用来简洁表达一组字符串的表达式。

如我们要表示这一组字符串数据：

```
'PN'
'PYN'
'PYTN'
'PYTHN'
'PYTHON'
```

我们用正则表达式只需要这样，是不是很简洁呢？

`P(Y|YT|YTH|YTHO)?N`

正则表达式有个特点叫“一行胜千言”，非常鲜明的说出了它的简洁的特点，也许你会说这才几个我直接写也不麻烦啊，但是如果是这样的呢：

```
'PY'
'PYY'
'PYYY'
'PYYYY'
...
```

或者这样的：

```
'PY'开头
后续存在不多于10个字符
后续字符不能是'P'或'Y'
    'PYABC'   √
    'PYKXYZ'  ×
```

像这样有某种特点，但是不能非常容易的枚举的一组字符串再使用正则表达式时很方便。

**正则表达式**：
* 通用的字符串表达框架
* 简洁表达一组字符串的表达式
* 针对字符串表达“简洁”和“特征”思想的工具
* 判断某字符串的特征归属

**正则表达式在文本处理中十分常用：**
* 表达文本类型的特征（病毒、入侵等）
* 同事查找或替换一组字符串
* 匹配字符串的全部或部分

**正则表达式的使用：**
* 编译：将符合正则表达式语法的字符串转换成正则表达式特征

### 2、正则表达式的语法

我们来看下正则表达式的语法是什么样的，首先还是看这个例子：

`P(Y|YT|YTH|YTHO)?N`

这里可以看出正则表达式语法由字符（Y、YT、YTH、YTHO）和操作符（（）、|、？）构成。那么正则表达式常用的操作符有：

| 操作符 | 说明                             | 实例                                    |
| :----: | :----: |:----: |
|   .    | 表示任何单个字符                 |                                         |
|   []   | 字符集，对单个字符给出取值范围   | [abc]表示a、b、c，[a-z]表示a到z单个字符 |
|  [^ ]  | 非字符集，对单个字符给出排除范围 | [^abc]表示非a或b或c的单个字符           |
|   *    | 前一个字符0次或无限次扩展        | abc*表示ab、abc、abcc、abccc等          |
|   +    | 前一个字符1次或无限次扩展        | abc+表示abc、abcc、abccc等              |
|   ？   | 前一个字符0次或1次扩展           | abc?表示ab、abc                         |
|   \|   | 左右表达式任意一个               | abc\|def表示abc、def                    |
|  {m}   | 扩展前一个字符m次                | ab{2}c表示abcc                          |
| {m,n}  | 扩展前一个字符m至n次（含n）      | ab{1，2}c表示abc、abcc                  |
|   ^    | 匹配字符串开头                   | ^abc表示abc且在一个字符串的开头         |
|   `$ `   | 匹配字符串结尾                   | `abc$`表示abc且在一个字符串的结尾         |
|   ()   | 分组标记，内部只能使用\|操作符   | (abc)表示abc，(abc\|def)表示abc、def    |
|   \d   | 数字，等价于[0-9]                |                                         |
|   \w   | 单词字符，等价于[A-Za-z0-9_]      |                                         |



然后我们结合前面那个实例对应一下相应的字符串：

`'PN'、'PYN'、'PYTN'、'PYTHN'、'PYTHON'`

再看几个别的例子：

```
# 正则表达式            对应字符串
PYTHON+                 'PYTHON'、'PYTHONN'、'PYTHONNN'……
PY[TH]ON                'PYTON'、'PYTHON'
PY[^TH]?ON              'PYON'、PYaON'、'PYbON'、'PYcON'……
PY{:3}N                 'PN'、'PYN'、PYYN'、'PYYYN'
```

我们看一下常见的经典正则表达式实例：

| 表达式                    | 释义                         |
| ------------------------- | ---------------------------- |
| `^[A-Za-z]+$`             | 由26个字母组成的字符串       |
| `^[A-Za-z0-9]+$`          | 由26个字母和数字组成的字符串 |
| `^-?\d+$`                 | 整数形式的字符串             |
| `^[0-9]*[1-9][0-9]*$`     | 正整数形式的字符串           |
| `[1-9]\d{5}`              | 中国境内邮政编码，6位        |
| `[\u4e00-\u9fa5]`         | 匹配中文字符                 |
| `\d{3}-\d{8}|\d{4}-\d{7}` | 国内电话号码，010-68913536   |

其中还有一个比较经典的正则表达式就是匹配IP地址的正则表达式：

`\d+.\d+.\d+.\d+`

或

`\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}`

但是这样的形式没有精确到数字（IP地址每一段最大为255），如果我们要精确可以这样：

```
# 精确写法
0-99：[1-9]?\d
100-199: 1\d{2}
200-249: 2[0-4]\d
250-255: 25[0-5]
```

合并起来就是这样的：

`(([1-9]?\d|1\d{2}|2{0-4}\d|25[0-5]).){3}([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5])`

###  3、Re库的基本使用

Re库是Python的标准库，主要用于字符串匹配，所以不需要额外安装，调用方式为：


```python
import re
```

正则表达式的表示类型：

* raw string类型（原生字符串类型，即不包含转义字符串的类型）

re库采用raw string类型表示正则表达式，则表示为：r'text'

例如：

```
r'[1-9]\d{5}'    # 国内邮政编码
r'\d{3}-\d{8}|\d{4}-\d{7}'   # 国内电话
```

* string类型，更繁琐

```
r'[1-9]\\d{5}'    # 国内邮政编码
r'\d{3}-\\d{8}|\\d{4}-\\d{7}'   # 国内电话
```

所以当字符串中包含转义字符时，尽量使用raw string类型.

* re库的主要功能函数

|     函数      |                             说明                             |
| :-----------: | :----------------------------------------------------------: |
|  re.search()  | 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象  |
|  re.match()   |     从一个字符串的开始位置匹配正则表达式，返回match对象      |
| re.findall()  |          搜索字符串，以列表类型返回全部能匹配的子串          |
|  re.split()   | 将一个字符串按照正则表达式匹配结果进行分割，返回子串列表类型 |
| re.finditer() | 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match()对象 |
|   re.sub()    | 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 |

下面我们来用实例来说明具体使用：

* **re.search(pattern，string，flags=0)：**在一个字符串中搜索匹配正则表达式的第一个位置返回match对象。 

pattern：正则表达式的字符串或原生字符串表示

string：待匹配字符串

flags：正则表达式使用时的控制标记，常用有以下三种：

|      常用标记      |                             说明                             |
| :----------------: | :----------------------------------------------------------: |
| re.I re.IGNORECASE |        忽略正则表达式的大小写，[A-Z]能够匹配小写字符         |
| re.M re.MULTILINE  |   正则表达式中的^操作符能够将给定字符串的每行当做匹配开始    |
|   re.S re.DOTALL   | 正则表达式中的.操作符能够匹配所有字符，默认匹配除换行外的所有字符 |

我们用实例看一下：


```python
import re
match = re.search(r'[1-9]\d{5}','BIT 100081')
if match:       # 判断是否为空
    print(match.group(0))
```

    100081


* **re.match(pattern，string，flags=0)：**从一个字符串的开始位置起匹配正则表达式，返回match对象 

pattern：正则表达式的字符串或原生字符串表示

string：待匹配字符串

flags：正则表达式使用时的控制标记

实例：


```python
import re
match = re.match(r'[1-9]\d{5}','BIT 100081')
if match:
    print(match.group(0))
```


```python
import re
match = re.match(r'[1-9]\d{5}','100081 BIT')
if match:
    print(match.group(0))
```

    100081


我们看到，最开始匹配的字符串开头是BIT，没有成功匹配到，当我们把100081放在开始位置时，才成功匹配到值。

*  **re.findall(pattern，string，flags)**：搜索字符串，以列表类型返回全部能匹配的子串 

pattern：正则表达式的字符串或原生字符串表示

string：带匹配字符串

flags：正则表达式使用时的控制标记

实例：


```python
import re
ls = re.findall(r'[1-9]\d{5}','BIT100081 TSU100084')
ls
```




    ['100081', '100084']



注意返回类型为列表类型。

*   **re.split(pattern，string，maxsplit=0，flags=0)**：将一个字符串按照正则表达式匹配结果进行分割，返回列表类型。

pattern：正则表达式的字符串或原声字符串表示

string：待匹配字符串

maxspilit：最大分隔数，剩余部分作为最后一个元素输出

flags：正则表达式使用时的控制标记


```python
import re
re.split(r'[1-9]\d{5}','BIT100081 TSU100084')
```




    ['BIT', ' TSU', '']




```python
re.split(r'[1-9]\d{5}','BIT100081 TSU100084',maxsplit=1)
```




    ['BIT', ' TSU100084']



*    **re.finditer(pattern，string，flags=0)：**搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 

pattern：正则表达式的字符串或原生字符串表示

string：带匹配字符串

flags：正则表达式使用时的控制标记

实例：


```python
import re
for m in re.finditer(r'[1-9]\d{5}','BIT100081 TSU100084'):
    if m:
        print(m.group(0))
```

    100081
    100084


* re.sub(pattern，repl，string，count=0，flags=0)：在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串。

pattern：正则表达式的字符串或原生字符串表示

string：带匹配字符串

flags：正则表达式使用时的控制标记

repl：替换匹配字符串的字符串

count：匹配的最大替换次数

实例：


```python
import re
re.sub(r'[1-9]\d{5}',':zipcode','BIT100081 TSU100084',1)
```




    'BIT:zipcode TSU100084'



另外，我们还可以使用Re库的另外一种等价用法：


```python
# 函数式用法：一次性操作
rst = re.search(r'[1-9]\d{5}','BIT 100081')

```

这里对应的等价用法就是：


```python
# 面向对象用法：编译后的多次操作
pat = re.compile(r'[1-9]\d{5}')
rst = pat.search('BIT 100081')
```

这里我们再介绍一个函数re.compile(pattern，flags=0)：将正则表达式的字符串形式编译成正则表达式对象

pattern：正则表达式的字符串或原生字符串表示

flags：正则表达式使用时的控制标记

这里我们使用compile()函数后就可以使用面向对象的方法匹配正则表达式了。

### 4、match对象

上一小节我们发现re的部分功能函数会表示返回一个match对象，那么match对象是什么？

事实上，**match就是一次匹配的结果，包含了一次匹配的信息**


```python
import re
match = re.search(r'[1-9]\d{5}','BIT 100081')
if match:
    print(match.group(0))
```

    100081



```python
type(match)
```




    re.Match



我们可以看到，返回的类型是re.match，在之前的python版本中还可能会返回这样一种形式：

`<class '_sre.SRE_Match'>`

但都标明这是一个match类型的对象，match对象有很多属性，下面介绍比较重要的四种：

|  属性   |                 说明                  |
| :-----: | :-----------------------------------: |
| .string |             待匹配的文本              |
|   .re   | 匹配时使用的pattern对象（正则表达式） |
|  .pos   |     正则表达式搜索文本的开始位置      |
| .endpos |     正则表达式搜索文本的结束位置      |

另外match对象还有几种比较常用的方法：

|   方法    |               说明               |
| :-------: | :------------------------------: |
| .group(0) |        获得匹配后的字符串        |
| .start()  | 匹配字符串在原始字符串的开始位置 |
|  .end()   | 匹配字符串在原始字符串的结束位置 |
|  .span()  |    返回元组(.start()，.end())    |

我们来实际操作一下：


```python
import re
m = re.search(r'[1-9]\d{5}','BIT100081 TSU100084')
m.string
```




    'BIT100081 TSU100084'




```python
m.re
```




    re.compile(r'[1-9]\d{5}', re.UNICODE)




```python
m.pos
```




    0




```python
m.endpos
```




    19




```python
m.group(0)
```




    '100081'




```python
m.start()
```




    3




```python
m.end()
```




    9




```python
m.span()
```




    (3, 9)



### 5、Re库的贪婪匹配和最小匹配

下面介绍一下Re库的贪婪匹配和最小匹配，首先来看一下下面这个实例，我们要**匹配N结尾的字符串**：


```python
import re
match = re.search(r'PY.*N','PYA88NBNCNDN')
match.group(0)
```




    'PYA88NBNCNDN'



这里我们发现，re库并没有返回所以可能的以N结尾的结果，如'PYAN'，'PYANBN'等，这是因为Re库默认采用贪婪匹配，即输出匹配最长的子串，那如果我们要匹配最短的匹配结果呢？


```python
import re
match = re.search(r'PY.*?N','PYANBNCNDN')
match.group(0)
```




    'PYAN'




```python
import re
match = re.search(r'PY.*?N','PY89ANBNCNDN')
match.group(0)
```




    'PY89AN'



如果我们在贪婪匹配的基础上实现最小匹配，我们要对以下4个操作符进行匹配：

|  操作符  |                 说明                  |
| :------: | :-----------------------------------: |
|    *?    |  前一个字符0次或无限次扩展，最小匹配  |
|    +?    |  前一个字符1次或无限次扩展，最小匹配  |
|   ？？   |   前一个字符0次或1次扩展，最小匹配    |
| {m，n}？ | 扩展前一个字符m至n次（含n），最小匹配 |

正则表达式相当于基本的语法使用


```python

```
